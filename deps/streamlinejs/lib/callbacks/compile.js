/*** Generated by streamline 0.10.1 (callbacks) - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; var fs = require("fs");








var fspath = require("path");
var compileSync = require("streamline/lib/compiler/compileSync");

var _exists = __rt.streamlinify(function(cb, fname) {
  fs.exists(fname, function(result) {
    cb(null, result); });

}, 0);

function mtime(_, fname) { var __frame = { name: "mtime", line: 19 }; return __func(_, this, arguments, mtime, 0, __frame, function __$mtime() { return (function __$mtime(_) {
      return _exists(__cb(_, __frame, 1, 8, function ___(__0, __1) { var __2 = __1; return (function __$mtime(__then) { if (__2) { return fs.stat(fname, __cb(_, __frame, 1, 28, function ___(__0, __4) { var __3 = __4.mtime; return _(null, __3); }, true)); } else { __then(); } ; })(function __$mtime() { return _(null, 0); }); }, true), fname); })(__cb(_, __frame, -18, 6, _, true)); });};


function _getTransform(options) {

  var req = require;
  if (options.generators) {
    if (options.fast) { return req("streamline/lib/generators-fast/transform"); } else {
      return req("streamline/lib/generators/transform") }; }
   else if (options.fibers) {
    if (options.fast) { return req("streamline/lib/fibers-fast/transform"); } else {
      return req("streamline/lib/fibers/transform") }; }
   else {
    return require("streamline/lib/callbacks/transform"); }  ;};



function _banner(version, options) {

  var optStr = (options.oldStyleFutures ? " --old-style-futures" : "");
  if (options.standalone) { optStr += " --standalone"; };
  return ((("/*** Generated by streamline " + version) + optStr) + " - DO NOT EDIT ***/");};


function _extend(obj, other) {
  for (var i in other) {
    obj[i] = other[i]; };

  return obj;};


function _transform(transform, source, options) {
  options.source = source;
  options.callback = (options.callback || "_");
  options.lines = (options.lines || "preserve");
  return transform.transform(source, options);};


function parseShebang(content) {
  if (((content[0] === "#") && (content[1] === "!"))) {
    var n = content.indexOf("\n");
    var le = "\n";
    if ((n != -1)) {
      var shebang = content.substr(0, n);
      if ((shebang[(shebang.length - 1)] == "\r")) {
        le = "\r\n";
        shebang = shebang.substr(0, (shebang.length - 1)); } ;

      content = content.substr((n + 1));
      return [shebang,content,le,]; } ; } ;


  return ["",content,"",];};


exports.compileFile = function exports_compileFile__1(_, path, options) { var ext, language, basename, dirname, dstName, mtimeSrc, mtimeDst, transform, banner, content, shebangparse, shebang, le, coffee, transformed, sourceMap, mapFile; var __frame = { name: "exports_compileFile__1", line: 75 }; return __func(_, this, arguments, exports_compileFile__1, 0, __frame, function __$exports_compileFile__1() {
    options = _extend({ }, (options || { }));
    ext = fspath.extname(path);
    language = ext.substring(2);
    basename = fspath.basename(path, ext);
    dirname = fspath.dirname(path);
    dstName = (((dirname + "/") + basename) + ".js");
    return mtime(__cb(_, __frame, 7, 16, function ___(__0, __2) { mtimeSrc = __2;
      return mtime(__cb(_, __frame, 8, 16, function ___(__0, __3) { mtimeDst = __3;
        transform = _getTransform(options);

        banner = _banner(transform.version, options);
        options.sourceName = path;
        return fs.readFile(path, "utf8", __cb(_, __frame, 13, 15, function ___(__0, __4) { content = __4;
          shebangparse = parseShebang(content);
          shebang = shebangparse[0];
          le = shebangparse[2];
          content = shebangparse[1];

          if ((language === "coffee")) {
            coffee = require("streamline/lib/util/require")("coffee-script");
            if (options.sourceMap) {
              content = coffee.compile(content, {
                filename: path,
                sourceFiles: [path,],
                sourceMap: 1 });

              options.prevMap = new (require("source-map").SourceMapConsumer)(content.v3SourceMap);
              content = content.js; }
             else {
              content = coffee.compile(content, {
                filename: path }); } ; } ;




          if (options.sourceMap) {
            options.lines = "sourcemap"; } ;


          banner = ((shebang + le) + banner); return (function __$exports_compileFile__1(_) {
            var __1 = mtimeDst; if (!__1) { return _(null, __1); } ; return fs.readFile(dstName, "utf8", __cb(_, __frame, 41, 31, _, true)); })(__cb(_, __frame, -74, 6, function ___(__0, __5) { transformed = __5;
            if ((((transformed && (mtimeSrc < mtimeDst)) && (transformed.substring(0, banner.length) == banner)) && !options.force)) {
              return _(null, transformed); } ;

            if (options.verbose) {
              console.log(("streamline: creating: " + dstName)); } ;

            transformed = _transform(transform, content, options);

            if ((typeof transformed == "string")) {
              transformed = (banner + transformed);
              if (options.prevMap) {
                transformed += (("\n//# sourceMappingURL=" + ((options.sourceMapFile || ((basename + ".map"))))) + "\n");
                sourceMap = require("source-map").SourceMapGenerator.fromSourceMap(options.prevMap);
                options.prevMap = null; } ; }

             else {
              transformed.prepend(banner);
              if (options.sourceMap) {
                transformed.add((("\n//# sourceMappingURL=" + ((options.sourceMapFile || ((basename + ".map"))))) + "\n"));
                sourceMap = transformed.toStringWithSourceMap({ file: dstName });
                transformed = sourceMap.code;
                sourceMap = sourceMap.map; } ; } ; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$exports_compileFile__1() {




                  return fs.writeFile(dstName, transformed, "utf8", __cb(_, __frame, 68, 2, __then, true)); }); })(function ___(ex, __result) { __catch(function __$exports_compileFile__1() { if (ex) { __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, function __$exports_compileFile__1() { return (function __$exports_compileFile__1(__then) {

                  if (options.sourceMap) {
                    if (options.prevMap) {
                      sourceMap.applySourceMap(options.prevMap, options.sourceName); } ; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$exports_compileFile__1() {


                          mapFile = (options.sourceMapFile || ((((dirname + "/") + basename) + ".map")));
                          if (options.verbose) { console.log(("streamline: creating: " + mapFile)); } ;
                          return fs.writeFile(mapFile, sourceMap.toString(), "utf8", __cb(_, __frame, 77, 3, __then, true)); }); })(function ___(ex, __result) { __catch(function __$exports_compileFile__1() { if (ex) { __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(_); }); }); }, true)); }, true)); }, true), dstName); }, true), path); });};









exports.loadFile = function exports_loadFile__2(_, path, options) { var ext, basename, dirname, js, transform, banner, content, shebangparse, shebang, le, matches; var __frame = { name: "exports_loadFile__2", line: 162 }; return __func(_, this, arguments, exports_loadFile__2, 0, __frame, function __$exports_loadFile__2() {
    options = _extend({ }, (options || { }));

    ext = fspath.extname(path); return (function __$exports_loadFile__2(__then) {
      if (((ext !== ".js") && (ext !== "._js"))) {

        return _exists(__cb(_, __frame, 6, 6, function ___(__0, __1) { return (function __$exports_loadFile__2(__then) { if (__1) { path = (path + (ext = "._js")); __then(); } else {
              return _exists(__cb(_, __frame, 7, 11, function ___(__0, __2) { return (function __$exports_loadFile__2(__then) { if (__2) { path = (path + (ext = ".js")); __then(); } else { return _(null); } ; })(__then); }, true), (path + ".js")); } ; })(__then); }, true), (path + "._js")); } else { __then(); } ; })(function __$exports_loadFile__2() {


      basename = fspath.basename(path, ext);
      dirname = fspath.dirname(path);

      js = (((dirname + "/") + basename) + ext);
      options.lines = (options.lines || "preserve");

      transform = _getTransform(options);
      banner = _banner(transform.version, options);
      options.sourceName = js;
      return fs.readFile(js, "utf8", __cb(_, __frame, 19, 15, function ___(__0, __3) { content = __3;
        shebangparse = parseShebang(content);
        shebang = shebangparse[0];
        le = shebangparse[2];
        content = shebangparse[1];

        banner = ((shebang + le) + banner); return (function __$exports_loadFile__2(__then) {

          if ((ext === "._js")) {
            return cachedTransform(__cb(_, __frame, 28, 9, _, true), content, path, transform, banner, options); } else {

            return _(null, content); } ; })(_); }, true)); }); });};



exports.transformModule = compileSync.transformModule;

function cacheRoot(options) {
  if (options.cacheDir) { return options.cacheDir };
  if (((process.env.HOME === undefined) && (process.env.HOMEDRIVE === undefined))) { throw new Error("HOME not found, unable to store Streamline callback cache") };
  return (((process.env.HOME || ((process.env.HOMEDRIVE + process.env.HOMEPATH)).replace(/\\/g, "/"))) + "/.streamline");};


var dirMode = parseInt("777", 8);

function mkdirs(_, path) { var p, i, segs, seg; var __frame = { name: "mkdirs", line: 206 }; return __func(_, this, arguments, mkdirs, 0, __frame, function __$mkdirs() {
    p = "";
    i = 0;
    segs = path.split("/").slice(0, -1); return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$mkdirs() { __more = false;
        var __3 = (i < segs.length); if (__3) {
          seg = segs[i];
          p += (((i++ ? "/" : "")) + seg);
          return _exists(__cb(_, __frame, 7, 7, function ___(__0, __2) { var __1 = !__2; return (function __$mkdirs(__then) { if (__1) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$mkdirs() {

                      return fs.mkdir(p, dirMode, __cb(_, __frame, 9, 4, __then, true)); }); })(function ___(err, __result) { __catch(function __$mkdirs() { if (err) {

                        if (((i > 1) && (err.code !== "EEXIST"))) {
                          return _(err); } ; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(function __$mkdirs() { while (__more) { __loop(); }; __more = true; }); }, true), p); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(_); });};






function subdir(options) {
  return (options.generators ? ((options.fast ? "generators-fast" : "generators")) : (options.fibers ? ((options.fast ? "fibers-fast" : "fibers")) : "callbacks"));};




function cachedTransform(_, content, path, transform, banner, options) { var i, dir, f, transformed; var __frame = { name: "cachedTransform", line: 231 }; return __func(_, this, arguments, cachedTransform, 0, __frame, function __$cachedTransform() {
    path = path.replace(/\\/g, "/"); return (function __$cachedTransform(__then) {
      if (options.cache) {
        i = path.indexOf("node_modules/");
        if ((i < 0)) { i = path.lastIndexOf("/"); } else {
          i += "node_modules".length; } ;

        dir = ((cacheRoot(options) + "/") + subdir(options));
        dir += ("/" + path.substring(0, i).replace(/[\/\:]/g, "__"));
        f = (dir + path.substring(i));
        return mkdirs(__cb(_, __frame, 10, 2, function __$cachedTransform() {

          return mtime(__cb(_, __frame, 12, 6, function ___(__0, __2) { return mtime(__cb(_, __frame, 12, 20, function ___(__0, __3) { var __1 = (__2 > __3); return (function __$cachedTransform(__then) { if (__1) {
                  return fs.readFile(f, "utf8", __cb(_, __frame, 13, 17, function ___(__0, __4) { transformed = __4;
                    if ((transformed.substring(0, banner.length) === banner)) { return _(null, transformed); } ; __then(); }, true)); } else { __then(); } ; })(__then); }, true), path); }, true), f); }, true), f); } else { __then(); } ; })(function __$cachedTransform() {



      if (options.verbose) { console.log(("streamline: transforming: " + path)); } ;
      options.lines = (options.lines || "sourcemap");
      transformed = (banner + _transform(transform, content, options)); return (function __$cachedTransform(__then) {
        if ((options.cache && (path.indexOf("/tmp--") < 0))) { return fs.writeFile(f, transformed, "utf8", __cb(_, __frame, 21, 50, __then, true)); } else { __then(); } ; })(function __$cachedTransform() {
        return _(null, transformed); }); }); });};


exports.cachedTransformSync = compileSync.cachedTransformSync;







exports.compile = function exports_compile__3(_, paths, options) { var failed, transform, cwd;
  function _compile(_, path, options) { var stat, ext, jsPath, source, coffee, compiled; var __frame = { name: "_compile", line: 265 }; return __func(_, this, arguments, _compile, 0, __frame, function __$_compile() {
      return fs.stat(path, __cb(_, __frame, 1, 13, function ___(__0, __3) { stat = __3; return (function __$_compile(__then) {
          if (stat.isDirectory()) {
            return fs.readdir(path, __cb(_, __frame, 3, 3, function ___(__0, __4) { return __4.forEach_(__cb(_, __frame, 3, 3, __then, true), function __1(_, f) { var __frame = { name: "__1", line: 268 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() {
                  return _compile(__cb(_, __frame, 1, 4, _, true), ((path + "/") + f), options); }); }); }, true)); } else { return (function __$_compile(__then) {

              if (stat.isFile()) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$_compile() {

                      return exports.loadFile(__cb(_, __frame, 8, 4, function __$_compile() {
                        ext = fspath.extname(path); return (function __$_compile(__then) {
                          if (((ext === "._js") || (ext === "._coffee"))) {
                            return exports.compileFile(__cb(_, __frame, 11, 5, __then, true), path, options); } else { return (function __$_compile(__then) {
                              if (((ext === ".coffee") && (path[((path.length - ext.length) - 1)] !== "_"))) {
                                jsPath = (path.substring(0, (path.length - ext.length)) + ".js"); return (function __$_compile(_) {
                                  var __2 = options.force; if (__2) { return _(null, __2); } ; return mtime(__cb(_, __frame, 14, 26, function ___(__0, __4) { return mtime(__cb(_, __frame, 14, 43, function ___(__0, __5) { var __3 = (__4 > __5); return _(null, __3); }, true), jsPath); }, true), path); })(__cb(_, __frame, -264, 6, function ___(__0, __5) { return (function __$_compile(__then) { if (__5) {
                                      return fs.readFile(path, "utf8", __cb(_, __frame, 15, 19, function ___(__0, __6) { source = __6;
                                        coffee = require("streamline/lib/util/require")("coffee-script");
                                        compiled = coffee.compile(source, {
                                          filename: path });

                                        if (options.verbose) { console.log(((("streamline: coffee compiling: " + path) + " to ") + jsPath)); } ;
                                        return fs.writeFile(jsPath, compiled, "utf8", __cb(_, __frame, 21, 6, __then, true)); }, true)); } else { __then(); } ; })(__then); }, true)); } else {


                                return exports.loadFile(__cb(_, __frame, 24, 5, __then, true), path, options); } ; })(__then); } ; })(__then); }, true), path, options); }); })(function ___(ex, __result) { __catch(function __$_compile() { if (ex) {


                        console.error(ex.stack);
                        failed++; __then(); } else { _(null, __result); } ; }); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(__then); } ; })(_); }, true)); }); }; var __frame = { name: "exports_compile__3", line: 264 }; return __func(_, this, arguments, exports_compile__3, 0, __frame, function __$exports_compile__3() {





    failed = 0;
    options = (options || { });
    transform = _getTransform(options);
    if (options.verbose) { console.log(("transform version: " + transform.version)); } ;
    if ((!paths || (paths.length == 0))) { return _(new Error("cannot compile: no files specified")); } ;
    cwd = process.cwd();
    return paths.forEach_(__cb(_, __frame, 41, 1, function __$exports_compile__3() {


      if (failed) { return _(new Error((("errors found in " + failed) + " files"))); } ; _(); }, true), function __1(_, path) { var __frame = { name: "__1", line: 305 }; return __func(_, this, arguments, __1, 0, __frame, function __$__1() { return _compile(__cb(_, __frame, 1, 2, _, true), fspath.resolve(cwd, path), options); }); }); });};
